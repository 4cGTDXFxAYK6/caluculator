<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>履歴付き電卓 (Refactored)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="theme-color" content="#000000">

<style>
  /* CSSは元のデザインを維持しています */
  :root{
    --bg:#000;
    --panel:rgba(255,255,255,0.08);
    --btn-dark:#333;
    --btn-gray:#a5a5a5;
    --btn-accent:#ff9f0a;
    --btn-accent2:#ffb347;
    --border:rgba(255,255,255,0.25);
  }

  html,body{
    height:100%; margin:0; background:var(--bg);
    font-family:-apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
    touch-action: manipulation;
  }
  body{ display:flex; align-items:center; justify-content:center; }

  .calculator{
    width:100%; max-width:600px; margin:auto; padding:16px; padding-bottom:40px;
    display:flex; flex-direction:column; gap:0; box-sizing:border-box;
  }

  .history{
    background:var(--panel); backdrop-filter:blur(8px); color:#fff;
    height:300px; padding:12px 8px; border-radius:14px; overflow:auto;
    font-size:21px; line-height:1.0; margin-bottom:14px;
    display: flex; flex-direction: column; gap: 4px; /* Flexに変更して並びを制御 */
  }

  .history-line{
    padding:6px 6px; border-radius:4px; display:flex; align-items:center;
    gap:10px; white-space:nowrap; overflow-x:auto; scrollbar-width:none;
    border-bottom:1px solid rgba(255,255,255,0.18);
    flex-shrink: 0; /* 潰れないように */
  }
  .history-line::-webkit-scrollbar{ display:none; }
  
  /* 入力中の行を目立たせる */
  .history-line.current-input {
    border-bottom: none;
    background: rgba(255,255,255,0.05);
    order: 999; /* 常に一番下へ */
  }

  .text{ flex:1; overflow:hidden; text-overflow:ellipsis; }

  .delete-btn{
    flex-shrink:0; color:var(--btn-accent); font-size:26px; font-weight:700;
    cursor:pointer; padding:0 8px;
  }

  .total-box{
    background:rgba(255,255,255,0.10); backdrop-filter:blur(6px); color:#fff;
    padding:12px 16px; border-radius:12px; font-size:26px; text-align:right; margin:0;
  }

  .keys{
    display:grid; grid-template-columns:repeat(4, 1fr); gap:0; width:100%;
  }

  button{
    position:relative; overflow:hidden; height:56px; border-radius:0;
    border:1px solid var(--border); font-size:24px; color:#fff;
    cursor:pointer; user-select:none; font-family:inherit;
    background: transparent;
    transition: background-color 0.1s;
  }

  button::after{
    content:""; position:absolute; left:50%; top:50%; width:0; height:0;
    background:rgba(255,255,255,0.45); border-radius:50%; transform:translate(-50%,-50%);
    opacity:0; transition:width .3s, height .3s, opacity .3s;
  }
  button.pressed::after{ width:180%; height:180%; opacity:1; }

  .op, .equal { background: linear-gradient(var(--btn-accent2), var(--btn-accent)); color:#000; font-weight:700; }
  .gray{ background:var(--btn-gray); color:#000; }
  .dark{ background:var(--btn-dark); }
  .zero{ grid-column:span 2; text-align:left; padding-left:28px; }

  @media (min-width:768px){ button{ height:74px; font-size:30px; } }
</style>
</head>
<body>

<div class="calculator">
  <div id="history" class="history">
    <div id="currentInputLine" class="history-line current-input">
        <span class="text">0</span>
    </div>
  </div>

  <div id="totalBox" class="total-box">合計: 0</div>

  <div class="keys">
    <button class="gray" data-value="DEL">⌫</button>
    <button class="gray" data-value="AC">AC</button>
    <button class="gray" data-value="%">%</button>
    <button class="op" data-value="/">÷</button>

    <button class="dark" data-value="7">7</button>
    <button class="dark" data-value="8">8</button>
    <button class="dark" data-value="9">9</button>
    <button class="op" data-value="*">×</button>

    <button class="dark" data-value="4">4</button>
    <button class="dark" data-value="5">5</button>
    <button class="dark" data-value="6">6</button>
    <button class="op" data-value="-">−</button>

    <button class="dark" data-value="1">1</button>
    <button class="dark" data-value="2">2</button>
    <button class="dark" data-value="3">3</button>
    <button class="op" data-value="+">＋</button>

    <button class="dark zero" data-value="0">0</button>
    <button class="dark" data-value=".">.</button>
    <button class="equal" data-value="=">=</button>
  </div>
</div>

<script>
/**
 * 状態管理（State）
 * DOMから値を読み取るのではなく、ここにあるデータを正とする
 */
const state = {
  current: "0",        // 現在入力中の数値（文字列）
  previous: null,      // 演算子の前に入力された数値（数値型）
  operator: null,      // 選択された演算子
  historyList: [],     // 確定した計算履歴 { id, expr, result }
  isNewInput: true     // 計算直後や演算子入力後の新規入力フラグ
};

// UI要素の取得
const els = {
  history: document.getElementById("history"),
  currentLine: document.querySelector("#currentInputLine .text"),
  totalBox: document.getElementById("totalBox"),
  keys: document.querySelector(".keys")
};

// --- ヘルパー関数 ---

// 数値を3桁区切り整形
const formatNum = (numStr) => {
  if (!numStr) return "";
  const n = Number(numStr);
  if (isNaN(n)) return "Error";
  // 小数点が含まれる場合の処理
  const parts = String(numStr).split(".");
  parts[0] = Number(parts[0]).toLocaleString("ja-JP");
  return parts.join(".");
};

// 演算子の表示変換
const formatOp = (op) => {
  const map = { '*': '×', '/': '÷', '+': '＋', '-': '−' };
  return map[op] || op;
};

// 安全な計算処理（eval不使用）
const safeCalculate = (a, b, op) => {
  const numA = Number(a);
  const numB = Number(b);
  
  // 浮動小数点誤差対策（簡易版: 精度が必要な場合はライブラリ推奨）
  // 一度整数にしてから計算するアプローチ
  const precision = 10000000000; 

  switch (op) {
    case '+': return (Math.round(numA * precision) + Math.round(numB * precision)) / precision;
    case '-': return (Math.round(numA * precision) - Math.round(numB * precision)) / precision;
    case '*': return (numA * precision * numB) / precision; // 乗算は少し注意が必要だが簡易的に
    case '/': 
      if (numB === 0) return "Error";
      return numA / numB;
    default: return numB;
  }
};

// --- ビュー更新 (Render) ---

const renderInputLine = () => {
  let text = "";
  if (state.previous !== null && state.operator) {
    text = `${formatNum(state.previous)} ${formatOp(state.operator)} ${formatNum(state.current)}`;
  } else {
    text = formatNum(state.current);
  }
  els.currentLine.textContent = text;
  
  // スクロールを下へ
  els.history.scrollTop = els.history.scrollHeight;
};

const renderTotal = () => {
  // 配列から合計を計算（高速かつ安全）
  const sum = state.historyList.reduce((acc, item) => acc + Number(item.result), 0);
  els.totalBox.textContent = "合計: " + formatNum(sum);
};

const renderHistoryItem = (item) => {
  const div = document.createElement("div");
  div.className = "history-line";
  div.dataset.id = item.id;
  div.innerHTML = `
    <span class="text">${item.expr} = ${formatNum(item.result)}</span>
    <span class="delete-btn">×</span>
  `;
  // 入力行（currentInputLine）の前に挿入
  els.history.insertBefore(div, document.getElementById("currentInputLine"));
  els.history.scrollTop = els.history.scrollHeight;
};

// --- ロジック ---

const handleNumber = (num) => {
  if (state.isNewInput) {
    state.current = num === "." ? "0." : num;
    state.isNewInput = false;
  } else {
    if (num === "." && state.current.includes(".")) return;
    state.current += num;
  }
  renderInputLine();
};

const handleOperator = (op) => {
  // 連続計算（1 + 2 + ... と押したとき）
  if (state.operator && !state.isNewInput && state.previous !== null) {
    executeCalculation();
  }
  
  state.operator = op;
  state.previous = state.current;
  state.isNewInput = true;
  renderInputLine();
};

const executeCalculation = () => {
  if (state.previous === null || !state.operator) return;

  const result = safeCalculate(state.previous, state.current, state.operator);
  
  // 履歴に追加
  const historyItem = {
    id: Date.now(),
    expr: `${formatNum(state.previous)} ${formatOp(state.operator)} ${formatNum(state.current)}`,
    result: result
  };
  
  state.historyList.push(historyItem);
  renderHistoryItem(historyItem);
  renderTotal();

  // 状態のリセット（結果を次の計算に使う）
  state.current = String(result); // 結果を入力値とするにはここを有効化してもよいが、今回はリセット挙動
  state.current = "0"; // あるいは結果を表示しつつ新規入力を待つ設計も可
  state.previous = null;
  state.operator = null;
  state.isNewInput = true;
  
  renderInputLine();
};

const handleDelete = () => {
  if (state.isNewInput) return;
  if (state.current.length === 1) {
    state.current = "0";
    state.isNewInput = true;
  } else {
    state.current = state.current.slice(0, -1);
  }
  renderInputLine();
};

const handleReset = () => {
  state.current = "0";
  state.previous = null;
  state.operator = null;
  state.isNewInput = true;
  state.historyList = [];
  
  // 履歴DOMの削除（inputLine以外）
  const lines = els.history.querySelectorAll('.history-line:not(#currentInputLine)');
  lines.forEach(line => line.remove());
  
  renderInputLine();
  renderTotal();
};

const handlePercent = () => {
    const val = Number(state.current);
    state.current = String(val / 100);
    renderInputLine();
}

// --- イベントリスナー ---

els.keys.addEventListener("click", e => {
  const btn = e.target.closest("button");
  if (!btn) return;

  // Rippleエフェクト
  btn.classList.add("pressed");
  setTimeout(() => btn.classList.remove("pressed"), 180);

  const val = btn.dataset.value;

  if (!isNaN(val) || val === ".") {
    handleNumber(val);
  } else if (["+", "-", "*", "/"].includes(val)) {
    handleOperator(val);
  } else if (val === "=") {
    executeCalculation();
  } else if (val === "AC") {
    handleReset();
  } else if (val === "DEL") {
    handleDelete();
  } else if (val === "%") {
      handlePercent();
  }
});

// 履歴削除ボタンのイベント委譲
els.history.addEventListener("click", e => {
  if (e.target.classList.contains("delete-btn")) {
    const line = e.target.closest(".history-line");
    const id = Number(line.dataset.id);
    
    // Stateから削除
    state.historyList = state.historyList.filter(item => item.id !== id);
    
    // DOMから削除
    line.remove();
    
    // 合計再計算
    renderTotal();
  }
});

// 初期化
renderInputLine();
</script>

</body>
</html>
